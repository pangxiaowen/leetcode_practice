# Day_39

## 买卖股票的最佳时机含手续费

### 题目

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

### 思路

1. 同一般的股票问题一样，只不过在卖出的时候考虑手续费即可
2. dp[i][0] 第i天， 持有股票状态下的最大利润； dp[i][1] 第i天，不持有股票状态下的最大利润。


## 最长递增子序列

### 题目

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

### 思路

1. dp[i] 包含nums[i]的递增子序列长度
2. DP公式
```
// 计算 0 ～ i 最长子序列长度
for(int j = 0; j < i; j++)
{
    if(nums[j] < nums[i])
    {
        dp[i] = std::max(dp[i], dp[j] + 1);
    }
}
```
3. 贪心的方式, 使用一个数组保存队列，保证队尾元素尽可能的小， 这样才能加入更多的元素。

## 最长连续递增序列

### 题目

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

### 思路

1. 在上一题目的基础上增加了连续的约束条件，
2. dp[i] 包含nums[i]的递增序列长度
3. DP公式
```
if(nums[i] > nums[i-1])
{
    dp[i] = dp[i-1] + 1;
}
```