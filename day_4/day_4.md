## day_4

### swap_pairs

* 建议使用虚拟头节点，避免对头节点的单独处理，基本所有的链表问题都适用，添加虚拟头，保证后续处理的统一性
* 可以画图先理清楚操作顺序，链表问题主要考虑断开的顺序，保证某一结点断开后，后续如果需要访问它，能够通过某种方式找到它。

![image-20241201181356845](..\images\image-20241201181237575.png)

### 删除链表的倒数第N个节点

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

需要确认的问题：

1. 链表是否为空

2. N的计数是从0还是从1开始？

3. 循环的终结条件是什么？ first->next == nullptr ? first == nullptr

   ![image-20241201191312353](..\images\image-20241201191312353.png)

### 链表相交

1. 暴力解法

     两个for循环逐个比较

2. 尾部对齐 :  求两个链表的长度，然后快慢指针， 快指针先移动N次

3. 两个链表交替遍历， cur_a  先遍历 A , 结束后再遍历B，cur_b 先遍历B，结束后再遍历A, 知道发现相同的节点。遇到相同节点的时候，他们的遍历次数的一致的

### 环形链表

参考： <https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF>
