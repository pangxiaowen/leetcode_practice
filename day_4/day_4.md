# day_4

## swap_pairs

### 题目

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

### 思路

* 建议使用虚拟头节点，避免对头节点的单独处理，基本所有的链表问题都适用，添加虚拟头，保证后续处理的统一性
* 可以画图先理清楚操作顺序，链表问题主要考虑断开的顺序，保证某一结点断开后，后续如果需要访问它，能够通过某种方式找到它。
* 使用pre, cur, next 三个指针，分别记录，前一个节点，当前节点，后一个节点， 另外记录遍历节点的个数count，如果count为偶数，则进行交换，否则指针++;
* 交换时候由于cur和next实际位置发生了改变，因此要对应去更新指针。

### 删除链表的倒数第N个节点

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

需要确认的问题：

1. 链表是否为空

2. N的计数是从0还是从1开始？

3. 循环的终结条件是什么？ first->next == nullptr ? first == nullptr

   ![image-20241201191312353](..\images\image-20241201191312353.png)

### 链表相交

1. 暴力解法

     两个for循环逐个比较

2. 尾部对齐 :  求两个链表的长度，然后快慢指针， 快指针先移动N次

3. 两个链表交替遍历， cur_a  先遍历 A , 结束后再遍历B，cur_b 先遍历B，结束后再遍历A, 知道发现相同的节点。遇到相同节点的时候，他们的遍历次数的一致的

### 环形链表

参考： <https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF>
