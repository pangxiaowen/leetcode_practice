# day_4

## swap_pairs

* 建议使用虚拟头节点，避免对头节点的单独处理，基本所有的链表问题都适用，添加虚拟头，保证后续处理的统一性
* 可以画图先理清楚操作顺序，链表问题主要考虑断开的顺序，保证某一结点断开后，后续如果需要访问它，能够通过某种方式找到它。

![image-20241201181356845](..\images\image-20241201181237575.png)

## 删除链表的倒数第N个节点

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

需要确认的问题：

1. 链表是否为空

2. N的计数是从0还是从1开始？

3. 循环的终结条件是什么？ first->next == nullptr ? first == nullptr

   ![image-20241201191312353](..\images\image-20241201191312353.png)

## 链表相交

### 题目

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

### 思路

1. 暴力解法 两个for循环逐个比较

2. 尾部对齐 :  求两个链表的长度，然后快慢指针， 快指针先移动N次

3. 两个链表交替遍历， cur_a  先遍历 A , 结束后再遍历B，cur_b 先遍历B，结束后再遍历A, 知道发现相同的节点。遇到相同节点的时候，他们的遍历次数的一致的，如果没有遇到相同的节点，则遍历到最后两个同时为nullptr。因为cur_a 和 cur_b 都需要完整的走过 A + B， 因此他们的移动次数是相同的，如果有相同的节点，cur_a和cur_b 必然会重逢。


## 环形链表

### 题目

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

### 思路

1. 首先确定链表是否有环，使用快慢指针进行确认，如果快慢指针相遇，则说明有环，如果快指针访问到链表末尾则说明无环，因为快指针访问速度快，只需要保证快指针以及fast->next有效即可

2. 判断环的入口节点。慢指针走过的路程为 x + y, (y 是在环内部走的距离)， 快指针走过的路程为 x + y + n(y + z), (n 是 快指针在圈内走了多少圈, y + z 等于一圈的长度)

注：需要知道一点， 由于快指针的速度是慢指针的2倍，因此在慢指针进入环后，快指针必定会在慢指针走完一圈之前追上它。

2(x + y) = x + y + n(y + z)
 
x + y = n(y + z)

x = n(y + z) - y = (n - 1) * y + nz = (n - 1)( y + z) + z

注： y + z 就是环的大小。
说明如果两个指针，一个从相遇点出发， 一个从起点出发，那么他们相遇的点就是进入环的点。

参考： <https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF>
