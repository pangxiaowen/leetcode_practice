# Day_31

## 合并区间

### 题目

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

### 思路

1. 先按照起始点进行排序
2. 记录 start, end， 如果当前节点的开始位置小于等于end，进行合并， 否则加入result并更新start，end

## 单调递增的数字

### 题目

给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

输入: N = 332
输出: 299

### 思路

1. 例如：98，一旦出现strNum[i - 1] > strNum[i]的情况（非单调递增），首先想让strNum[i - 1]--，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。

2. 满足其各个位数上的数字是单调递增, 从低位到高位进行遍历, 如果低位大于高位，那高位减1，低位全部置为9

[0 .... n .... end]， 保证0~n是有序的， n~end 全部是9。


## 监控二叉树

### 题目

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。

### 思路

1. 想要摄像头的数量最少，那么叶子节点不能放置摄像头，因为叶子节点没有子结点，覆盖范围小。

2. 从底向上遍历整颗树，如果左右节点有一个没有被覆盖，则在当前节点加入摄像头，返回当前节点状态。

3. 状态定义 0 没有覆盖 1 该点是摄像头 2 被覆盖
