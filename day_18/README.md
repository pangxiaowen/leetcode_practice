# Day_18

## 二叉搜索树的最小绝对差

### 题目

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

### 思路

1. 中序遍历二叉搜索树，得到的是有序的序列，根据这个序列求差值即可。
2. 遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了
3. 迭代 和 递归 都可以
4. 遍历的时候，记录前一个节点的指针。

## 二叉搜索树中的众数

### 题目

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

    结点左子树中所含结点的值小于等于当前结点的值
    结点右子树中所含结点的值大于等于当前结点的值
    左子树和右子树都是二叉搜索树

### 思路

1. 由于众数可能多个，因此要使用std::vector对数组进行保存。
2. 采用中序遍历的方式， 统计相同元素的个数， 如果前一个元素和后一个元素不同，则说明上一个元素计数结束，需要重新计数。如果相同则cur_count++
3. 判断前一个元素的计数和最大计数的关系
    * cur_count <  max_count  不更新vector
    * cur_count == max_count  将元素的值插入vector
    * cur_count >  max_count  清空vector, 并插入元素的值，更新max_count
5. 暴力解法，遍历整个树，使用map统计元素出现的次数。

## 二叉树的最近公共祖先

### 题目

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

### 思路

1. 寻找节点的公共祖先，采用后序遍历，左右中的方式
2. 判断左树，右树中是否存在需要的节点， 如果都有则说明它是公共祖先，对结果进行return.
3. 要留意一种情况， p 是 q的祖先， 那么p就是他们的公共祖先。对p 直接返回即可，不用做额外处理。
4. 后序是一种回溯，自底向上，一层层的恢复。由子问题的解推出来整体的解。
5. 关于返回值的问题
    ```
    if(Traversal(cur->left))
        return;
    if(Traversal(cur->right))
        return;
    ```
    如果对返回值进行if判断决定是否return，会导致只遍历一部分的树
    ```
    Traversal(cur->left)
    Traversal(cur->right)
    ```
    遍历整颗树

* 求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。

* 在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。

* 要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。