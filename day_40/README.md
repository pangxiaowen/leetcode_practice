# Day_40

## 最长公共子序列 

### 题目

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

### 思路

1. 下标的含义
    dp[i][j] 最后一个元素为nums[i - 1] 和 最后一个元素为nums[j - 1] 的字符串的最长公共子序列长度

2. DP公式

    if(nums[i - 1] == nums[ j - 1])
        dp[i][j] = dp[i-1][j-1] + 1
    else
        dp[i][j] = std::max(dp[i-1][j], dp[i][j-1])

3. 初始化
    dp[0][0], dp[i][0], dp[0][j] 均为0即可

4. 遍历顺序
    由于dp[i][j] 依赖于 dp[i-1][j-], dp[i][j-1], dp[i-1][j] 等值， 因此，遍历顺序为0~i, 0~j


## 不相交的线

### 题目

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：

    nums1[i] == nums2[j]
    且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

### 思路

1. 本题其实就是求最长公共子序列，最长公共子序列满足上述要求。
2. 基本思路同上。

## 最大子序和

### 题目

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

### 思路

1. 下标的含义
    dp[i] 包含nums[i]的连续子数组的最大和

2. DP公式
    if(dp[i - 1] > 0)
        dp[i] = dp[i - 1] + nums[i]
    else
        dp[i] = nums[i];
3. 初始化
    dp[0] = nums[0];

4. 遍历顺序
    dp[i] 由 dp[i-1] 推导出来，遍历顺序为 0～i

## 判断子序列

### 题目

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

### 思路

1. 暴力解法，逐个判断s中的字符是否在t中，
```
for(int i = 0; i < t.size(); i++>)
{
if(s[index] = t[i])
    index++;
}
```

2. 动态规划
```
1. 求s 和 t的最大公共子序列长度， 如果最大公共子序列长度等于s，则说明s是t的子序列

2. 下标含义
    dp[i][j] 包含s[i-1] 和 t[j-1]的最大公共子序列长度

3. DP公式
    if(s[i-1] == t[j-1])
    {
        dp[i][j] = dp[i-1][j-1] + 1;
    }
    else
    {
        dp[i][j] = std::max(dp[i][j-1], dp[i-1][j])
    }

4. 遍历顺序
    0~i 0~j
```

