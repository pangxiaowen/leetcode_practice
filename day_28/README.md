# Day_28

## 买卖股票的最佳时机 II

### 题目

给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

### 思路

1. 下标含义

dp[i][0] 第i天持有股票获得的最大利润

dp[i][1] 第i天卖出股票获得的最大利润

2. DP 公式

dp[i][0] = std::max(dp[i-1][0], dp[i-1][1] - nums[i])
dp[i][1] = std::max(dp[i-1][1], dp[i-1][0] + nums[i])

3. 初始化

dp[0][0] = -nums[0];
dp[0][1] = 0;

4. 遍历顺序

0~i

### 思路2

1. 贪心的方式，只要能赚，就卖出
2. [7,1,5,3,6,4] --> [-6, 4, -2, 3, -2] --> 7



## 跳跃游戏

### 题目

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

### 思路

1. 根据跳跃的最大长度，计算跳跃的覆盖范围，判断是否能够覆盖最后一个位置

2. 只能在覆盖范围内，选择起跳的位置


## 跳跃游戏 II

### 题目

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

### 思路

1. 贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。

2. 要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！


## K次取反后最大化的数组和

### 题目

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。

### 思路

1. 对数组进行排序，每次选择最小的那个变化符号，重复k次


### 思路2

1. 第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
2. 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
3. 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
4. 第四步：求和