# Day_41

## 不同的子序列

### 题目

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

### 思路

1. 下标含义
dp[i][j], dp[i][j]  表示 s 的前 i 个字符中，t 的前 j 个字符的子序列个数

2. DP公式

```
if (s[i - 1] == t[j - 1])
   dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
else
   dp[i][j] = dp[i - 1][j];
```

3. 初始化

dp[i][0] = 1, 表示空字符串 t 在 s 的前 i 个字符中出现的次数为 1

dp[0][j] = 0, 表示非空字符串 t 在空字符串 s 中出现的次数为 0

dp[0][0] = 1, 表示空字符串 t 在空字符串 s 中出现的次数为 1

## 两个字符串的删除操作

### 题目

给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

示例：

* 输入: "sea", "eat"
* 输出: 2
* 解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"

### 思路

1. 本题目只进行删除操作，求出两个单字的最大公共子序列长度，然后word.size - substr.size 
2. 求word1 和 word2 的最大公共子序列
3. 下标含义
    dp[i][j] 包含wrod1[i-1] 和 word2[j-1]的 字符串的最大公共子序列长度
4. DP公式

```
if(word1[i-1] == word2[j-1])
    dp[i][j] = dp[i-1][j-1] + 1;
else
    dp[i][j] = std::max(dp[i-1][j], dp[i][j-1])

```

5. 初始化
    全为0即可

### 思路2

1. 下标的含义 \
dp[i][j]  包含wrod1[i-1] 和 word2[j-1]的 字符串的相同所需要的最小步数

2. DP 公式 

```
if(word1[i-1] == word2[j-1])
    dp[i][j]  = dp[i-1][j-1]
else
    dp[i][j] = std::min(dp[i-1][j], dp[i][j-1]) + 1;

1. 把i-1 删除掉， dp[i-1][j] + 1
2. 把j-1 删除掉， dp[i][j-1] + 1
3. 把i-1 和 j-1 都删除掉， dp[i-1][j-1] + 2

由于 dp[i-1][j-1] + 2 与 dp[i-1][j] + 1 是相同的，因此只考虑前两种情况即可

由于j-1 是要删除的，所以 dp[i-1][j-1] + 1 == dp[i-1][j] 
```

## 编辑距离

### 题目

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

*  插入一个字符

*  删除一个字符

*  替换一个字符

### 思路

1. 下标含义 

dp[i][j] 包含wrod1[i-1] 和 word2[j-1]的 字符串的相同所需要的最小步数

2. DP方程

```
if(word1[i-1] == word2[j-1])
{
    dp[i][j] = dp[i-1][j-1];
}
else
{
    // 增
    // 删
    // 改
    dp[i][j] = std::min(std::min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1;
}
```

* 增，给word1 增加元素，相当于word2中删除元素， dp[i][j] = dp[i][j-1] + 1;
* 删，删除word1中的元素， dp[i][j] = dp[i-1][j] + 1;
* 改，将word1[i-1]改成word2[j-1], dp[i][j] = dp[i-1][j-1] + 1;

3. 初始化

dp[0][0] = 0;
dp[i][0] = i; // 将word1的元素全部删除
dp[0][j] = j; // 将word2的元素全部删除

4. 遍历顺序 \
0~i 0~j


##  回文子串

### 题目

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

### 思路

1. 如果[i, j] 是回文字串， 那么[i+1, j-1] 也是回文字串
2. 下标含义 \
    dp[i][j] i~j 之间的字符串是否是回文字串，包含(str[i], str[j])
3. DP公式 
```
    if(str[i] == str[j])
    {
        if(j - i <= 1)
        {
            dp[i][j] = true;
        }else if(dp[i+1][j-1])
        {
            dp[i][j] = true;
        }
    }
    else
    {
        dp[i][j] = false;
    }
```
4. 初始化 \
    dp[i][i] 是回文字串 \
    其他初始化为false即可。 \
    因为DP公式中 存在if(i-j <= 1) 的判断，全初始化 为0也可以

5. 遍历顺序 \

    由于 dp[i][j] 跟 dp[i + 1][ j - 1] 有关

    i --> [ i ~ 0] 

    j --> [0 ~ j] 

    j > i 

## 最长回文子序列

### 题目

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

示例 1: 输入: "bbbab" 输出: 4 一个可能的最长回文子序列为 "bbbb"。

示例 2: 输入:"cbbd" 输出: 2 一个可能的最长回文子序列为 "bb"。

### 思路

1. 求字符串s中的最长的回文子序列，就是求 s 和 s.reverse 的最长公共子序列

2. 下标含义 \
    dp[i][j] 包含nums1[i-1] 和 nums2[j-1]的最长公共子序列

3. DP公式 \
    if(nums1[i-1] == nums2[j-1])
    {
        dp[i][j] = dp[i-1][j-1] + 1;
    }
    else
    {
        dp[i][j] = std::min(dp[i-1][j], dp[i][j-1]);
    }

4. 初始化 \
    dp[0][0], dp[0][j], dp[i][0] 无意义，初始化为0即可

5. 遍历顺序 \
    由于dp[i][j] 由dp[i-1][j-1], dp[i][j-1], dp[i-1][j] 推导出来，
    所以 0 ~ i, 0 ~ j 

## 思路2

回文子串是要连续的，回文子序列可不是连续的！该思路是求连续的回文字串长度，不适合本题目

1. 下标含义 \
    dp[i][j] --> [i, j] 区间内的字串是否为回文字串 \
    substr_len = j - i + 1
2. DP公式 \
    if(str[i] == str[j])
    {
        if(j - i <= 1)
        {
            substr_len = std::max(substr_len, j - i + 1);
            dp[i][j] = true;
        }else if(dp[i+1][j-1])
        {
            substr_len = std::max(substr_len, j - i + 1);
            dp[i][j] = true; 
        }
    }
3. 初始化 \
    全为false即可

4. 遍历顺序 \

   dp[i][j] 由 dp[i + 1][j - 1] 推导

   i --> i ~ 0 \
   j --> i ~ j 

## 思路3

1. 下标含义 \
    dp[i][j] [i, j] 范围内的最长回文子序列

2. DP公式 \
    if(str[i] == str[j])
    {
        dp[i][j] = dp[i+1][j-1] + 2;
    }
    else
    {
        dp[i][j] = std::max(dp[i+1][j], dp[i][j-1]);
    }
3. 初始化 \
    dp[i][i] = 1; 其余为0

4. 遍历顺序 \
    dp[i][j] 由 dp[i+1][j-1], dp[i+1][j], dp[i][j-1] 推导出来 \
    i --> [i ~ 0] \
    j --> [i ~ j] \
