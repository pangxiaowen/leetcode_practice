# Day_35

## 完全背包问题

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。

完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。

## 思路

### 二维数组

* 和01背包问题的主要区别在与DP公式与初始化， 由于物体可以被多次原则，因此在初始化的时候要考虑0号物体被多次放入。\ 

构造DP公式的时候 dp[i][j] = std::max(dp[i-1][j], dp[i][j - w[i]] + v[i])

### 一维数组

* 区别在于遍历顺序，
    01背包问题，只能for(objs){for(bag_size)}, 同时，遍历bag_size的时候，需要从大到小遍历，因为物体不能重复放入，\
    从后往前 dp[j] = std::max(dp[j], dp[j- w[i]] + v[i]), 此时的dp[j - w[i]] 是没有被加入 v[i]的状态。 \

    完全背包问题， 由于物体可以被多次放入，因此不存在遍历顺序的限制， 遍历bag_size 的时候，要从小到大 \
    dp[j] = std::max(dp[j], dp[j- w[i]] + v[i]), 在使用dp[j]的时候，要保证d[j - w[i]] 被初始化。

## 零钱兑换II

### 题目

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

### 思路

1. 主要条件，硬币的金额不为0，0在求和 组合数的时候比较特殊
2. 将其转化为背包问题， 总金额数是背包大小， 求多少种组合能把背包装满。

```
dp[j] += dp[j - w[i]]

```
3. 先for 物品, 再for 背包大小, 求组合问题 \
   先for 背包大小, 再for 物品, 求排序问题

## 组合总和 Ⅳ

## 题目

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:

    nums = [1, 2, 3]
    target = 4

所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。

## 思路

同上，该问题是排序问题。


##  爬楼梯（进阶版）

### 题目

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

输入描述：输入共一行，包含两个正整数，分别表示n, m

输出描述：输出一个整数，表示爬到楼顶的方法数。

输入示例：3 2

输出示例：3

提示：

当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。

此时你有三种方法可以爬到楼顶。

    1 阶 + 1 阶 + 1 阶段
    1 阶 + 2 阶
    2 阶 + 1 阶

### 思路

1. 将其转转化为完全背包问题， 背包大小是n, 物体是{1~m}, 求有多少种方式填满背包
2. 同事这是一个排序问题， 背包大小是4，  1, 1, 2 和 1， 2， 1 是不同的方式

## 零钱兑换

### 题目

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

### 思路

1. 每种硬币无限，可以多次选取， 转化为完全背包问题 
2. 确认dp数组下标的含义： dp[j], 组成整数j所需要最少的硬币个数
3. dp公式: dp[j] = std::min(dp[j], dp[j - coins[i]] + 1)
4. 初始化: dp[0] = 0