# Day_14

## 对称二叉树

### 题目

给定一个二叉树，检查它是否是镜像对称的。

### 思路

1. 该题目的目的是判断根节点的左右子树是不是镜像对称的。
2. 对于左子树的遍历顺序是左右中， 对于右子树的遍历的顺序要做镜像，右左中
3. 递归法: 
    * 函数的返回值以及参数，需要返回值用于标识左右是否镜像对称，参数，左右树的指针
    * 终止条件，判断出不对称的时候返回false，对称返回true
    * 递归体
    ```
    bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
    bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
    bool isSame = outside && inside;                    // 左子树：中、 右子树：中（逻辑处理）
    ```

4. 递归法: 
    * 对两个树进行遍历，只不过遍历的顺序不同
    * 左 --> 中左右  右 --> 中右左

##  翻转二叉树

### 题目

翻转一棵二叉树。

### 思路

1. 层序遍历，遇到节点就交换它的左右节点
2. 递归， 前后序遍历，递归体中交换左右节点
3. 迭代法，对用统一写法来说，由于遍历和处理是分开的，因此处理的时候交换左右节点即可。
4. 递归中序， 由于交换之后， 左节点是原来的右节点，因此递归的时候要做相应的修改
```
if (root == NULL) return root;
invertTree(root->left);         // 左
swap(root->left, root->right);  // 中
invertTree(root->left);         // 注意 这里依然要遍历左孩子，因为中间节点已经翻转了
return root;
```

## 二叉树的最大深度

### 题目

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例： 给定二叉树 [3,9,20,null,null,15,7]，

### 思路

1. 层序遍历的方式，遍历到最后一层就是最大深度

2. 递归的方式, 将深度作为参数传入，如果遇到更深的层，更新depth
使用前序求的就是深度，使用后序求的是高度。

## 二叉树的最小深度

### 题目

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],

### 思路

1. 层序遍历，遇到左右子树都是空的时候返回即可
2. 递归，前序和后序均可
