# Day_36

## 零钱兑换

### 题目

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

### 思路

1. 转化为完全背包问题
2. dp[i] = std::min(dp[i], dp[i-coins[i]] + 1)
3. 由于是求最小， dp[0~i] = INT_MAX
4. dp[0] = 0, 金额为0的时候无需硬币
5. 当dp[i-coins[i]] == INT_MAX 的时候， 说明dp[i-coins[i]]还没有被计算，因此先跳过。
6. 遍历方式，最少个数，不涉及排列组合。

## 完全平方数

### 题目

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

### 思路

1. 转化为完全背包问题，使用完全平方数填满 n
2. 所有的完全平方是 0～i  i*i <=n
3. dp[j], 填满j所需要的最少个数
4. dp[j] = std::min(dp[j], dp[ j - i*i] + 1)


## 单词拆分

### 题目

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。

你可以假设字典中没有重复的单词。

### 思路

1. dp[j] 长度为j的字符串，能否被拆成一个或者多个单词
2. 如果 dp[j] = true, 那[i, j] 这个子串在字典中出现， dp[i] = true \
DP公式： if(find([i, j]) && dp[j]) dp[i] = true;

## 打家劫舍

### 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

### 思路

1. 该题目使用动态规划的方法去做，因为当前的状态依赖于上一个状态
2. 当前的屋子是否能偷窃，依赖于上一个屋子 \
    dp[j] = std::max(dp[j-1], dp[j-2] + value[j]) 
3. 初始化， dp[0] = nums[0], dp[1] = std::max(nums[1], nums[0])

