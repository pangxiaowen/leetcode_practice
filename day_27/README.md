# Day_27

## 分发饼干

### 题目

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

### 思路

1. 先对 g 和 s 进行从大到小的排序， 先用大饼干满足胃口的大的孩子

## 摆动序列

### 题目

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)  是正负交替出现的。相反, [1,4,7,2,5]  和  [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例 1:
    输入: [1,7,4,9,2,5]
    输出: 6
    解释: 整个序列均为摆动序列。

示例 2:

    输入: [1,17,5,10,13,15,10,5,16,8]
    输出: 7
    解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。

示例 3:

    输入: [1,2,3,4,5,6,7,8,9]
    输出: 2

### 思路

1. 动态规划

对于序列的任意一个数字，存在两种状态，处于波峰 或者 处于波谷

dp[i][0] 第i个数字处于波峰时候的最长子序列长度

dp[i][1] 第i个数字处于波谷时候的最长子序列长度

2. DP公式

* dp[i][0] = max(dp[i][0], dp[j][1] + 1)，其中0 < j < i且nums[j] < nums[i]，表示将 nums[i]接到前面某个山谷后面，作为山峰。

* dp[i][1] = max(dp[i][1], dp[j][0] + 1)，其中0 < j < i且nums[j] > nums[i]，表示将 nums[i]接到前面某个山峰后面，作为山谷。

```

if(nums[i] > nums[j])
    dp[i][0] = max(dp[i][0], dp[j][1] + 1)

if(nums[i] < nums[j])
    dp[i][1] = max(dp[i][1], dp[j][0] + 1)
    
```


## 最大子序和

### 题目

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

    输入: [-2,1,-3,4,-1,2,1,-5,4]
    输出: 6
    解释:  连续子数组  [4,-1,2,1] 的和最大，为  6。

### 思路

1. 下标含义

dp[i] 包含nums[i]的最大和

2. DP 公式 

dp[i] = std::max(nums[i], dp[i-1] + nums[i]);

3. 初始化

dp[0] = nums[0];

4. 遍历顺序

0～i

### 思路2

1. 滑动窗口的方法，保证滑动窗口内的总和大于0，如果右边加入一个数，导致总体小于零，则左边开始出队

直到窗口内的总和是大于0的

