# Day_33

## 整数拆分

### 题目

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

### 思路

1. 确认DP数组下标的含义， DP[i] 整数i的最大乘积
2. 确认DP公式
    DP[i] = std::max(DP[i], std::max(j*(i-j), DP[i-j]*j))
3. 初始化
    DP[1] = 1
    DP[2] = 1
4. 确认遍历顺序
    从小到大
5. 模拟测试


## 不同的二叉搜索树

### 题目

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

### 思路

1. 该题目的难点是找规律，即找出DP公式。
2. 对于DP数组的下标的含义， 只需要DP[0]即可

## 0_1 背包问题

### 题目

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

###

1. 一维DP数组 和 而二维DP数组含义不同
    * 一维
    ```
    dp[j], 当背包大小为j时候的最大价值
    DP公式为 dp[j] = std::max(dp[j], dp[j - w[i] + v[i]])
    DP数组初始化为0即可
    先遍历物品，再遍历背包，背包从大到小遍历。
    ```
    * 二维度
    ```
    dp[i][j], 在0～i中任意选物品，当背包大小为j时候的最大价值。
    DP公式为 dp[i][j] = std::max(dp[i-1][j], dp[i-1][j - w[i]] + v[i])

    DP数组， 要初始化dp[i][0], 以及dp[0][j]    
    先遍历物品或者背包都可以
    ```
