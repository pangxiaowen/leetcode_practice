## Day1

#### 二分查找

二分查找的使用条件： 有序, 无重复元素

区间的范围: 左开右闭 || 左闭右开

```
    // 左闭右开 --> 最右边的值取不到的
    int left = 0;
    int right = vec.size();

    // 左闭右闭 --> 最右边的值可以取到
    int left = 0;
    int right = vec.size() - 1;
```

两种情况对应的while(conda), conda 是不同的需要注意，同时在二分查找取边界的时候，也要注意右边界的处理，建议使用左闭右开的处理方式。

同时要注意， 当vec[mid] != target, 更新left或者right的时候，不能直接赋值（left = mid）, 因为已经验证了vec[mid]不是所需要的值，需要mid±1， 写的时候要考虑清楚。

#### 删除重复元素

数组是连续的，所以数组删除元素，只能够覆盖。如何实现高效的覆盖，是主要思考方向。如果删除一次，就把后续的元素拷贝一边，复杂度比较高。

1. 暴力解法
   两个for循环，第一个for循环用来遍历数组，第二个用于更新数组，当发现目标值的时候，将后续的元素向前拷贝一格

2. 快慢指针
   1. 当val不是目标值的时候， slow和fast同时++, 若val是目标值，则fast++,并跳出当前循环， 若slow!=fast, 则将fast处的值赋给slow
   2. 当val不是目标值的时候，将fast处的值赋给slow, slow和fast同时++, 否则fast++

3. 当val是目标值的时候， 将第size-1个元素赋值给val, 并且index--, size--

#### 有序数组的平方

对于数组如果想要获得O(N)的计算复杂度，一般考虑双指针法， 快慢指针, 头尾双指针 \
观察规律性，总结一般规律，根据规律进行求解。 \
如果没有要求原地排序，需要考虑另外开辟空间进行求解。\

暴力解法：
    每个数字求平方之后，再进行排序

双指针法：
    分析数组存在的规律性:

    1. 数组是有序的
    2. 数组的平方的最大值，不是出现在最左边就是出现在最右边

​    使用两个指针，分别指向头和尾，判断两个值的大小，将大的部分，放入到新数组的最右端，两个指针逐步向中间靠拢，缩小数据范围。
