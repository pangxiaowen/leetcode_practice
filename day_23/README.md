# Day_23

## 组合总和

### 题目

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：
    所有数字（包括 target）都是正整数。
    解集不能包含重复的组合。

### 思路

1. 元素可以无限选取, 因此递归的时候，start_index不用+1
2. 没有重复元素，因此不用考虑重复的组合，不需要去重。


## 组合总和II

### 题目

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。

### 思路

1. 解集不能包含重复的组合。为了去重，首先要对数组进行排序。
2. 一个组合里面的数据是可以重复的，因此，在递归的时候需要去重。
3. 每个数字只能使用一次，因此递归的时候 start_index + 1
4. 使用used数组进行去重， 如果used[i-1] == false， 则说明同一层已经使用过 nums[i-1]。 因为for循环的遍历顺序是0~i \
used[i-1] = true, 同一树枝上使用过nums[i-1]

## 分割回文串

### 题目

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例: 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ]

### 思路

1. 分割问题， 先找到一个分割点， 然后在剩下的部分中寻找下一个分割点。然后不断的回溯。我们可以把这个过程抽象成一个树
递归用来纵向遍历，for循环用来横向遍历，切割线切割到字符串的结尾位置，说明找到了一个切割方法。
2. 回文串，对称的字符串。


