# Day_37

## 打家劫舍II

### 题目

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

### 思路

1. 相比I, 这里的房屋是一个圈， 增加了一个限制， 头尾不能同时选。
2. 我们将数组分为两个组， [0, end - 1] 不包含最后一个元素， [1, end] 不包含第一个元素。 分别求最值，然后再取最大的那个。


## 打家劫舍 III

### 题目

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

### 思路

1. 当前节点偷不偷，决定了left和right是否能偷。
2. 采用后序遍历的方式，来遍历整个树。
3. 返回值为， {偷当前节点时的最大值， 不偷当前节点的最大值}， 这个来递归解决问题
4. 返回值为， 当前节点的最大值，那么需要判断，当前节点偷或者不偷，那个价值更高。分两种情况递归，最后判断，这种方式会造成多余的计算，可以使用unordered_map进行缓存。


## 买卖股票的最佳时机

### 题目

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

### 思路

1. 暴力解法 \
    遍历取一个数字，其他数字减去当前值，然后计算最大的差值。
2. 贪心  \
    从左到右遍历的时候，记录遍历过的数字的最小值，然后计算最大的差值。
3. 动态规划  \
    1. dp[i][0] 0~i 中的某一天购买股票后，手中的现金是多少
       dp[i] = std::max(dp[i - 1][0], -price[i])
       如果 dp[i] = dp[i - 1][0], 说明之前买股票， 第i天是持有之前的股票，并没有交易产生。
       如果 dp[i] = -price[i]， 说明 第i天买了股票。
    2. dp[i][1] 0~i 中的某一天将股票卖出，手中的现金是多少
       dp[i][1] = std::max(dp[i - 1][1], dp[i][0] + price[i])
       如果 dp[i][1] == dp[i - 1][1], 说明第i天没有交易
       如果 dp[i][1] == dp[i][0] + price[i]， 说明第i天将股票卖出。


