# Day_21

## 修剪二叉搜索树

### 题目

给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

### 思路

1. 递归，从顶到下进行处理。
    *  判断当前节点是否小与low，如果小于，则返回该节点右子树的处理结果。
    *  判断当前节点是否大于high， 如果大于，则返回该节点左子树的处理结果。
    *  如果当前节点 low < cur < high, 则对该节点的左右子树进行处理，返回当前节点。
2. 迭代的方式
    * 先将root移动至[low, high]区间内部。使得顶点在区间内部，然后修剪左右边界。
    * 修剪左边界
    * 修剪右边界

## 将有序数组转换为二叉搜索树

### 题目

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

### 思路

1. 本题是有序数据，因此，如果要构建高度平衡的二叉搜索树，递归使用中间节点当顶点构造即可。
2. 选取区间内的中间值，构建一个node， 调整区间范围，构建左右子树木。
3. 返回node.

## 把二叉搜索树转换为累加树

### 题目

给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。

### 思路

1. 采用右中左的遍历顺序
2. 存储前一个节点的指针。
3. 将前一个节点的val加到当前节点上。
